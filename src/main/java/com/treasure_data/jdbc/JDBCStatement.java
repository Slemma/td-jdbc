package com.treasure_data.jdbc;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import org.hsqldb.StatementTypes;
import org.hsqldb.jdbc.JDBCResultSet;
import org.hsqldb.result.Result;

import com.treasure_data.client.ClientException;
import com.treasure_data.client.TreasureDataClient;
import com.treasure_data.jdbc.internal.CommandExecutor;
import com.treasure_data.model.Database;
import com.treasure_data.model.Job;
import com.treasure_data.model.SubmitJobRequest;
import com.treasure_data.model.SubmitJobResult;

public class JDBCStatement extends JDBCAbstractStatement implements Statement {

    private TreasureDataClient client;

    private Database database;

    private CommandExecutor exec;

    private int fetchSize = 50;

    /**
     * We need to keep a reference to the result set to support the following:
     * <code>
     * statement.execute(String sql);
     * statement.getResultSet();
     * </code>.
     */
    private ResultSet currentResultSet = null;

    /**
     * The maximum number of rows this statement should return (0 => all rows).
     */
    private int maxRows = 0;

    /**
     * Add SQLWarnings to the warningChain if needed.
     */
    private SQLWarning warningChain = null;

    /**
     * Keep state so we can fail certain calls made after close().
     */
    private boolean isClosed = false;

    public JDBCStatement(TreasureDataClient client, Database database) {
        this.client = client;
        this.database = database;
    }

    public void addBatch(String sql) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public void cancel() throws SQLException {
        throw new SQLException("Method not supported");
    }

    public void clearBatch() throws SQLException {
        throw new SQLException("Method not supported");
    }

    public void clearWarnings() throws SQLException {
        warningChain = null;
    }

    public void close() throws SQLException {
        client = null;
        currentResultSet = null;
        isClosed = true;
    }

    public boolean execute(String sql) throws SQLException {
        ResultSet rs = executeQuery(sql);

        // TODO: this should really check if there are results, but there's no easy
        // way to do that without calling rs.next();
        return rs != null;
    }

    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public boolean execute(String sql, String[] columnNames) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public int[] executeBatch() throws SQLException {
        throw new SQLException("Method not supported");
    }

    public synchronized ResultSet executeQuery(String sql) throws SQLException {
        fetchResult(sql);
        return getResultSet();
    }

    private void fetchResult(String sql) throws SQLException { // TODO
        closeResultData(); // TODO

        if (isEscapeProcessing) {
            sql = nativeSQL(sql);
        }

        try {
            Result out = Result.newExecuteDirectRequest();
            out.setPrepareOrExecuteProperties(sql, maxRows, fetchSize,
                    StatementTypes.RETURN_RESULT,
                    queryTimeout, rsProperties,
                    JDBCAbstractStatement.NO_GENERATED_KEYS, null, null);
            Result in = exec.execute(out);
            //resultIn = exec.execute(resultOut);
            performPostExecute();
        } catch (Exception e) { // TODO
            throw new SQLException(e);
        }

        if (resultIn.isError()) {
            throw new SQLException("in fetchResult"); // TODO
        }

        if (resultIn.isData()) {
            currentResultSet = new TreasureDataQueryResultSet(
                    client, resultIn, resultIn.metaData); // TODO
        } else if (resultIn.getStatementType() == StatementTypes.RETURN_RESULT) {
            getMoreResults();
        }
    }

    private void closeResultData() throws SQLException {
        // TODO
    }

    public ResultSet executeQuery0(String sql) throws SQLException {
        // TODO
        Job job = new Job(database, sql);

        // submit a job
        try {
            currentResultSet = null;
            SubmitJobRequest request = new SubmitJobRequest(job);
            SubmitJobResult result = client.submitJob(request);
            job = result.getJob();
        } catch (ClientException e) {
            throw new SQLException(e.toString(), "08S01");
        }

        // get the result of the job
        currentResultSet = new TreasureDataQueryResultSet(client, maxRows, job);
        currentResultSet.setFetchSize(fetchSize);
        return currentResultSet;
    }

    public int executeUpdate(String sql) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public Connection getConnection() throws SQLException {
        throw new SQLException("Method not supported");
    }

    public int getFetchDirection() throws SQLException {
        throw new SQLException("Method not supported");
    }

    public int getFetchSize() throws SQLException {
        return fetchSize;
    }

    public ResultSet getGeneratedKeys() throws SQLException {
        throw new SQLException("Method not supported");
    }

    public int getMaxFieldSize() throws SQLException {
        throw new SQLException("Method not supported");
    }

    public int getMaxRows() throws SQLException {
        return maxRows;
    }

    public boolean getMoreResults() throws SQLException {
        return getMoreResults(JDBCAbstractStatement.CLOSE_CURRENT_RESULT);
    }

    public boolean getMoreResults(int current) throws SQLException {
        return super.getMoreResults(current);
    }

    public int getQueryTimeout() throws SQLException {
        throw new SQLException("Method not supported");
    }

    public ResultSet getResultSet() throws SQLException {
        ResultSet result = currentResultSet;
        currentResultSet = null;
        return result;
    }

    public int getResultSetConcurrency() throws SQLException {
        throw new SQLException("Method not supported");
    }

    public int getResultSetHoldability() throws SQLException {
        throw new SQLException("Method not supported");
    }

    public int getResultSetType() throws SQLException {
        throw new SQLException("Method not supported");
    }

    public int getUpdateCount() throws SQLException {
        return 0;
    }

    public SQLWarning getWarnings() throws SQLException {
        return warningChain;
    }

    public boolean isClosed() throws SQLException {
        return isClosed;
    }

    public boolean isPoolable() throws SQLException {
        throw new SQLException("Method not supported");
    }

    public void setCursorName(String name) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public void setEscapeProcessing(boolean enable) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public void setFetchDirection(int direction) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public void setFetchSize(int rows) throws SQLException {
        fetchSize = rows;
    }

    public void setMaxFieldSize(int max) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public void setMaxRows(int max) throws SQLException {
        if (max < 0) {
            throw new SQLException("max must be >= 0");
        }
        maxRows = max;
    }

    public void setPoolable(boolean poolable) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public void setQueryTimeout(int seconds) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        throw new SQLException("Method not supported");
    }

    public <T> T unwrap(Class<T> iface) throws SQLException {
        throw new SQLException("Method not supported");
    }

    // TODO implementing
    public synchronized String nativeSQL(final String sql) throws SQLException {
        // boucherb@users 20030405
        // FIXME: does not work properly for nested escapes
        //       e.g.  {call ...(...,{ts '...'},....)} does not work
        // boucherb@users 20030817
        // TESTME: First kick at the FIXME cat done.  Now lots of testing
        // and refinment

        // CHECKME:  Thow or return null if input is null?
        if (sql == null || sql.length() == 0 || sql.indexOf('{') == -1) {
            return sql;
        }

        // boolean   changed = false;
        int state = 0;
        int len   = sql.length();
        int nest  = 0;
        StringBuffer sb = new StringBuffer(sql.length());    //avoid 16 extra
        String msg;

        //--
        final int outside_all                         = 0;
        final int outside_escape_inside_single_quotes = 1;
        final int outside_escape_inside_double_quotes = 2;

        //--
        final int inside_escape                      = 3;
        final int inside_escape_inside_single_quotes = 4;
        final int inside_escape_inside_double_quotes = 5;

        // TODO:
        // final int inside_single_line_comment          = 6;
        // final int inside_multi_line_comment           = 7;
        // Better than old way for large inputs and for avoiding GC overhead;
        // toString() reuses internal char[], reducing memory requirment
        // and garbage items 3:2
        sb.append(sql);

        for (int i = 0; i < len; i++) {
            char c = sb.charAt(i);

            switch (state) {

                case outside_all :                            // Not inside an escape or quotes
                    if (c == '\'') {
                        state = outside_escape_inside_single_quotes;
                    } else if (c == '"') {
                        state = outside_escape_inside_double_quotes;
                    } else if (c == '{') {
                        i = onStartEscapeSequence(sql, sb, i);

                        // changed = true;
                        nest++;

                        state = inside_escape;
                    }
                    break;

                case outside_escape_inside_single_quotes :    // inside ' ' only
                case inside_escape_inside_single_quotes :     // inside { } and ' '
                    if (c == '\'') {
                        state -= 1;
                    }
                    break;

                case outside_escape_inside_double_quotes :    // inside " " only
                case inside_escape_inside_double_quotes :     // inside { } and " "
                    if (c == '"') {
                        state -= 2;
                    }
                    break;

                case inside_escape :                          // inside { }
                    if (c == '\'') {
                        state = inside_escape_inside_single_quotes;
                    } else if (c == '"') {
                        state = inside_escape_inside_double_quotes;
                    } else if (c == '}') {
                        sb.setCharAt(i, ' ');

                        // changed = true;
                        nest--;

                        state = (nest == 0) ? outside_all
                                            : inside_escape;
                    } else if (c == '{') {
                        i = onStartEscapeSequence(sql, sb, i);

                        // changed = true;
                        nest++;

                        state = inside_escape;
                    }
            }
        }

        return sb.toString();
    }

    /**
     * is called from within nativeSQL when the start of an JDBC escape
     * sequence is encountered
     */
    private int onStartEscapeSequence(String sql, StringBuffer sb, int i)
            throws SQLException {
        sb.setCharAt(i++, ' ');

        i = skipSpaces(sql, i);

        if (sql.regionMatches(true, i, "fn ", 0, 3)
                || sql.regionMatches(true, i, "oj ", 0, 3)
                || sql.regionMatches(true, i, "ts ", 0, 3)) {
            sb.setCharAt(i++, ' ');
            sb.setCharAt(i++, ' ');
        } else if (sql.regionMatches(true, i, "d ", 0, 2)
                   || sql.regionMatches(true, i, "t ", 0, 2)) {
            sb.setCharAt(i++, ' ');
        } else if (sql.regionMatches(true, i, "call ", 0, 5)) {
            i += 4;
        } else if (sql.regionMatches(true, i, "?= call ", 0, 8)) {
            sb.setCharAt(i++, ' ');
            sb.setCharAt(i++, ' ');

            i += 5;
        } else if (sql.regionMatches(true, i, "escape ", 0, 7)) {
            i += 6;
        } else {
            i--;

            throw new SQLException("invalid JDBC argument", "S0010");
        }

        return i;
    }

    private static int skipSpaces(String s, int start) {
        int limit = s.length();
        int i = start;

        for (; i < limit; i++) {
            if (s.charAt(i) != ' ') {
                break;
            }
        }

        return i;
    }
}
